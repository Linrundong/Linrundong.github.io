[TOC]

### 保证成功投递
- ==nsq保证了"至少一次"成功投递，而不是仅一次==
- 通过client.subChannel.StartInFlightTimeout()协程

#### protocolV2处理对象
##### protocolV2.messagePump()协程
- 在向订阅的client发送消息前，会在(开始投递超时处理)subChannel.StartInFlightTimeout()记录超时信息
```
func (p *protocolV2) messagePump(client *clientV2, startedChan chan bool) {
    ...
		select {
        ...
		case msg := <-memoryMsgChan:
            ...
            // 发送前，在subChannel.StartInFlightTimeout()标记消息
			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)
			// 向订阅的此client发送消息
			client.SendingMessage()
			err = p.SendMessage(client, msg)
			if err != nil {
				goto exit
			}
			flushed = false
		case <-client.ExitChan:
			goto exit
		}
	}
}
```

##### 标记超时时间-subchannel.StartInFlightTimeout()
- 在当前client的subchannel使用messageID标记msg
- msg.pri记录超时时间
- 向subchannel的inFlightPQ消息数组添加此消息(压入栈顶)
```
func (c *Channel) StartInFlightTimeout(msg *Message, clientID int64, timeout time.Duration) error {
	now := time.Now()
	msg.clientID = clientID
	msg.deliveryTS = now
	msg.pri = now.Add(timeout).UnixNano()

	// 给subchannel使用messageID标记msg
	err := c.pushInFlightMessage(msg)
	if err != nil {
		return err
	}
	// 向subchannel的inFlightPQ消息数组添加此消息
	c.addToInFlightPQ(msg)
	return nil
}
```

##### 检索出超时消息-channel.processInFlightQueue()
- 读取inFlightPQ消息队列
- 判断是否超时，超时了则通知并重新发送

```
// queueScanWorker任务会传入当前时间到t
func (c *Channel) processInFlightQueue(t int64) bool {
	// 同步状态，防止正在这个channel正在退出
	c.exitMutex.RLock()
	defer c.exitMutex.RUnlock()

	if c.Exiting() {
		return false
	}

	dirty := false
	// 循环处理inFlightPQ消息队列栈顶消息
	for {
		c.inFlightMutex.Lock()
		// 没有超时，则返回nil, 然后goto exit->return dirty
		// 超时了，inFlightPQ弹出并返回msg
		msg, _ := c.inFlightPQ.PeekAndShift(t)
		c.inFlightMutex.Unlock()

		if msg == nil {
			goto exit
		}
		// 只要发送过消息，则标记此subchannel为dirty
		dirty = true

		// 删除超时消息对应channel的inFlightMessages消息map
		_, err := c.popInFlightMessage(msg.clientID, msg.ID)
		if err != nil {
			goto exit
		}
		atomic.AddUint64(&c.timeoutCount, 1)
		c.RLock()
		client, ok := c.clients[msg.clientID]
		c.RUnlock()
		if ok {
			// 向超时消息对应client发送超时通知
			client.TimedOutMessage()
		}
		// 重新发送消息
		c.put(msg)
	}

exit:
	return dirty
}
```

### 定时检查任务-queueScanWorker
> 如果一条消息一直没有被消费，nsqd如何处理？<br>
> 参考《Redis设计与实现》9.6 Redis的过期键删除策略，结合了两种策略：<br>
> 惰性删除。每次客户端对某个key读写时，会检查它是否过期，如果过期，就把它删掉。<br>
> 定期删除。定期删除并不会遍历整个DB，它会在规定时间内，分多次遍历服务器中各个DB，从数据库的expires字典中随机检查一部分键的过期时间，如果过期，则删除。


- **定期检查**：==queueScanLoop方法中，每隔QueueScanInterval的时间，会从方法cache的channels list中随机选择QueueScanSelectionCount个channel，然后去执行resizePool。==
- 在nsqd进程的Main线程中启动 queueScanWorker

```
func (n *NSQD) Main() {
    ...
	// 超时消息检索和处理任务
	n.waitGroup.Wrap(n.queueScanLoop)
	n.waitGroup.Wrap(n.lookupLoop)
}
```
